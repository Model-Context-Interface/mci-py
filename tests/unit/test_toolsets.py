"""
Unit tests for toolset loading and filtering functionality.

Tests the new toolsets feature including:
- Loading toolsets from library directories
- Schema-level filtering (only, except, tags, withoutTags)
- Adapter-level filtering with toolsets() method
- Toolset file discovery (directory vs file)
- Error handling for invalid toolsets
"""

import json
from pathlib import Path

import pytest

from mcipy.client import MCIClient, MCIClientError
from mcipy.models import MCISchema, Toolset
from mcipy.parser import SchemaParser, SchemaParserError


class TestToolsetLoading:
    """Test loading toolsets from library directory."""

    def test_load_single_toolset_file(self, tmp_path):
        """Test loading a single toolset file."""
        # Create library directory and toolset file
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "weather.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {
                    "name": "get_weather",
                    "execution": {"type": "text", "text": "Weather data"}
                }
            ]
        }))
        
        # Create main schema with toolset reference
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "weather"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify tool was loaded
        assert schema.tools is not None
        assert len(schema.tools) == 1
        assert schema.tools[0].name == "get_weather"
        assert schema.tools[0].toolset_source == "weather"

    def test_load_toolset_directory(self, tmp_path):
        """Test loading a toolset from a directory with multiple files."""
        # Create library directory and toolset directory
        lib_dir = tmp_path / "mci"
        toolset_dir = lib_dir / "github"
        toolset_dir.mkdir(parents=True)
        
        # Create multiple toolset files in directory
        (toolset_dir / "prs.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {
                    "name": "list_prs",
                    "execution": {"type": "text", "text": "PRs"}
                }
            ]
        }))
        
        (toolset_dir / "issues.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {
                    "name": "list_issues",
                    "execution": {"type": "text", "text": "Issues"}
                }
            ]
        }))
        
        # Create main schema
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "github"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify both tools were loaded
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"list_prs", "list_issues"}
        # All tools should have same toolset source
        assert all(tool.toolset_source == "github" for tool in schema.tools)

    def test_load_multiple_toolsets(self, tmp_path):
        """Test loading multiple toolsets."""
        # Create library directory with multiple toolsets
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "weather.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "get_weather", "execution": {"type": "text", "text": "Weather"}}
            ]
        }))
        
        (lib_dir / "database.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "query_data", "execution": {"type": "text", "text": "Query"}}
            ]
        }))
        
        # Create main schema referencing both toolsets
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "weather"},
                {"name": "database"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify both tools were loaded
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"get_weather", "query_data"}

    def test_load_toolset_with_extension(self, tmp_path):
        """Test loading a toolset file specified with .mci.json extension."""
        # Create library directory and toolset file
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "custom.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "custom_tool", "execution": {"type": "text", "text": "Custom"}}
            ]
        }))
        
        # Create main schema with explicit extension
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "custom.mci.json"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify tool was loaded
        assert schema.tools is not None
        assert len(schema.tools) == 1
        assert schema.tools[0].name == "custom_tool"

    def test_toolset_not_found(self, tmp_path):
        """Test error when toolset file is not found."""
        # Create empty library directory
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        # Create main schema referencing non-existent toolset
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "nonexistent"}
            ]
        }))
        
        # Should raise error
        with pytest.raises(SchemaParserError, match="Toolset not found: nonexistent"):
            SchemaParser.parse_file(str(main_schema))

    def test_library_dir_not_found(self, tmp_path):
        """Test error when library directory doesn't exist."""
        # Create main schema without creating library directory
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "weather"}
            ]
        }))
        
        # Should raise error about missing library directory
        with pytest.raises(SchemaParserError, match="Library directory not found"):
            SchemaParser.parse_file(str(main_schema))

    def test_custom_library_dir(self, tmp_path):
        """Test using a custom library directory."""
        # Create custom library directory
        custom_lib = tmp_path / "custom_toolsets"
        custom_lib.mkdir()
        
        toolset_file = custom_lib / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "custom_tool", "execution": {"type": "text", "text": "Custom"}}
            ]
        }))
        
        # Create main schema with custom libraryDir
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "libraryDir": "./custom_toolsets",
            "toolsets": [
                {"name": "tools"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify tool was loaded
        assert schema.tools is not None
        assert len(schema.tools) == 1
        assert schema.tools[0].name == "custom_tool"


class TestSchemaLevelFiltering:
    """Test schema-level filtering in toolsets."""

    def test_filter_only(self, tmp_path):
        """Test 'only' filter at schema level."""
        # Create toolset with multiple tools
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}},
                {"name": "tool2", "execution": {"type": "text", "text": "Tool 2"}},
                {"name": "tool3", "execution": {"type": "text", "text": "Tool 3"}}
            ]
        }))
        
        # Create main schema with 'only' filter
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "only",
                    "filterValue": "tool1, tool3"
                }
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify only tool1 and tool3 were loaded
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"tool1", "tool3"}

    def test_filter_except(self, tmp_path):
        """Test 'except' filter at schema level."""
        # Create toolset with multiple tools
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}},
                {"name": "tool2", "execution": {"type": "text", "text": "Tool 2"}},
                {"name": "tool3", "execution": {"type": "text", "text": "Tool 3"}}
            ]
        }))
        
        # Create main schema with 'except' filter
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "except",
                    "filterValue": "tool2"
                }
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify tool2 was excluded
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"tool1", "tool3"}

    def test_filter_tags(self, tmp_path):
        """Test 'tags' filter at schema level."""
        # Create toolset with tagged tools
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "read_tool", "tags": ["read"], "execution": {"type": "text", "text": "Read"}},
                {"name": "write_tool", "tags": ["write"], "execution": {"type": "text", "text": "Write"}},
                {"name": "mixed_tool", "tags": ["read", "write"], "execution": {"type": "text", "text": "Mixed"}}
            ]
        }))
        
        # Create main schema with 'tags' filter
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "tags",
                    "filterValue": "read"
                }
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify only tools with 'read' tag were loaded
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"read_tool", "mixed_tool"}

    def test_filter_withoutTags(self, tmp_path):
        """Test 'withoutTags' filter at schema level."""
        # Create toolset with tagged tools
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "safe_tool", "tags": ["read"], "execution": {"type": "text", "text": "Safe"}},
                {"name": "danger_tool", "tags": ["write", "destructive"], "execution": {"type": "text", "text": "Danger"}},
                {"name": "neutral_tool", "tags": [], "execution": {"type": "text", "text": "Neutral"}}
            ]
        }))
        
        # Create main schema with 'withoutTags' filter
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "withoutTags",
                    "filterValue": "destructive"
                }
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify tools without 'destructive' tag were loaded
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"safe_tool", "neutral_tool"}

    def test_filter_value_whitespace_handling(self, tmp_path):
        """Test that filterValue handles whitespace correctly."""
        # Create toolset
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}},
                {"name": "tool2", "execution": {"type": "text", "text": "Tool 2"}},
                {"name": "tool3", "execution": {"type": "text", "text": "Tool 3"}}
            ]
        }))
        
        # Create main schema with whitespace in filterValue
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "only",
                    "filterValue": " tool1 ,  tool2  , tool3 "
                }
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify all tools were loaded (whitespace trimmed)
        assert schema.tools is not None
        assert len(schema.tools) == 3

    def test_filter_without_value_error(self, tmp_path):
        """Test error when filter is specified without filterValue."""
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}}
            ]
        }))
        
        # Create main schema with filter but no filterValue
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "only"
                }
            ]
        }))
        
        # Should raise error
        with pytest.raises(SchemaParserError, match="filterValue is missing"):
            SchemaParser.parse_file(str(main_schema))

    def test_invalid_filter_type(self, tmp_path):
        """Test error when invalid filter type is specified."""
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        toolset_file = lib_dir / "tools.mci.json"
        toolset_file.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}}
            ]
        }))
        
        # Create main schema with invalid filter type
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "invalid",
                    "filterValue": "tool1"
                }
            ]
        }))
        
        # Should raise error
        with pytest.raises(SchemaParserError, match="Invalid filter type 'invalid'"):
            SchemaParser.parse_file(str(main_schema))


class TestAdapterLevelFiltering:
    """Test adapter-level filtering with toolsets() method."""

    def test_toolsets_method(self, tmp_path):
        """Test filtering tools by toolset name using toolsets() method."""
        # Create library directory with multiple toolsets
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "weather.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "get_weather", "execution": {"type": "text", "text": "Weather"}}
            ]
        }))
        
        (lib_dir / "database.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "query_data", "execution": {"type": "text", "text": "Query"}}
            ]
        }))
        
        # Create main schema
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "weather"},
                {"name": "database"}
            ]
        }))
        
        # Load client
        client = MCIClient(schema_file_path=str(main_schema))
        
        # Filter by weather toolset
        weather_tools = client.toolsets(["weather"])
        assert len(weather_tools) == 1
        assert weather_tools[0].name == "get_weather"
        
        # Filter by database toolset
        database_tools = client.toolsets(["database"])
        assert len(database_tools) == 1
        assert database_tools[0].name == "query_data"
        
        # Filter by both toolsets
        all_toolset_tools = client.toolsets(["weather", "database"])
        assert len(all_toolset_tools) == 2
        tool_names = {tool.name for tool in all_toolset_tools}
        assert tool_names == {"get_weather", "query_data"}

    def test_toolsets_empty_list(self, tmp_path):
        """Test that empty toolset list returns no tools."""
        # Create library directory with toolset
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "weather.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "get_weather", "execution": {"type": "text", "text": "Weather"}}
            ]
        }))
        
        # Create main schema
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "weather"}
            ]
        }))
        
        # Load client
        client = MCIClient(schema_file_path=str(main_schema))
        
        # Filter with empty list
        tools = client.toolsets([])
        assert len(tools) == 0

    def test_toolsets_with_main_tools(self, tmp_path):
        """Test that toolsets() only returns tools from toolsets, not main tools."""
        # Create library directory with toolset
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "weather.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "get_weather", "execution": {"type": "text", "text": "Weather"}}
            ]
        }))
        
        # Create main schema with both main tools and toolsets
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "main_tool", "execution": {"type": "text", "text": "Main"}}
            ],
            "toolsets": [
                {"name": "weather"}
            ]
        }))
        
        # Load client
        client = MCIClient(schema_file_path=str(main_schema))
        
        # All tools should include both
        all_tools = client.tools()
        assert len(all_tools) == 2
        
        # toolsets() should only return toolset tools
        toolset_tools = client.toolsets(["weather"])
        assert len(toolset_tools) == 1
        assert toolset_tools[0].name == "get_weather"

    def test_toolsets_respects_schema_filter(self, tmp_path):
        """Test that toolsets() only includes tools registered by schema-level filter."""
        # Create toolset with multiple tools
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "tools.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}},
                {"name": "tool2", "execution": {"type": "text", "text": "Tool 2"}},
                {"name": "tool3", "execution": {"type": "text", "text": "Tool 3"}}
            ]
        }))
        
        # Create main schema with schema-level filter (only load tool1 and tool2)
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {
                    "name": "tools",
                    "filter": "only",
                    "filterValue": "tool1, tool2"
                }
            ]
        }))
        
        # Load client
        client = MCIClient(schema_file_path=str(main_schema))
        
        # toolsets() should only return tools that passed schema-level filter
        toolset_tools = client.toolsets(["tools"])
        assert len(toolset_tools) == 2
        tool_names = {tool.name for tool in toolset_tools}
        assert tool_names == {"tool1", "tool2"}


class TestCombinedFiltering:
    """Test combining schema-level and adapter-level filtering."""

    def test_toolsets_with_adapter_only_filter(self, tmp_path):
        """Test combining toolsets() with only() filter."""
        # Create toolset
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "tools.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}},
                {"name": "tool2", "execution": {"type": "text", "text": "Tool 2"}},
                {"name": "tool3", "execution": {"type": "text", "text": "Tool 3"}}
            ]
        }))
        
        # Create main schema
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "tools"}
            ]
        }))
        
        # Load client
        client = MCIClient(schema_file_path=str(main_schema))
        
        # First filter by toolset, then by only()
        # Note: This requires applying both filters
        toolset_tools = client.toolsets(["tools"])
        assert len(toolset_tools) == 3
        
        # Now use only() - it works on all tools
        only_tools = client.only(["tool1", "tool2"])
        assert len(only_tools) == 2


class TestMixedToolsAndToolsets:
    """Test schemas with both main tools and toolsets."""

    def test_tools_and_toolsets_merged(self, tmp_path):
        """Test that main tools and toolset tools are merged."""
        # Create toolset
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "extra.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "extra_tool", "execution": {"type": "text", "text": "Extra"}}
            ]
        }))
        
        # Create main schema with both tools and toolsets
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "main_tool", "execution": {"type": "text", "text": "Main"}}
            ],
            "toolsets": [
                {"name": "extra"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify both tools are present
        assert schema.tools is not None
        assert len(schema.tools) == 2
        tool_names = {tool.name for tool in schema.tools}
        assert tool_names == {"main_tool", "extra_tool"}
        
        # Main tool should not have toolset_source
        main_tool = next(t for t in schema.tools if t.name == "main_tool")
        assert main_tool.toolset_source is None
        
        # Extra tool should have toolset_source
        extra_tool = next(t for t in schema.tools if t.name == "extra_tool")
        assert extra_tool.toolset_source == "extra"

    def test_only_toolsets_no_main_tools(self, tmp_path):
        """Test schema with only toolsets, no main tools."""
        # Create toolset
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "tools.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}}
            ]
        }))
        
        # Create main schema with only toolsets
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "tools"}
            ]
        }))
        
        # Load schema
        schema = SchemaParser.parse_file(str(main_schema))
        
        # Verify tool was loaded from toolset
        assert schema.tools is not None
        assert len(schema.tools) == 1
        assert schema.tools[0].name == "tool1"


class TestToolsetSchemaValidation:
    """Test validation of toolset schema files."""

    def test_toolset_missing_tools_field(self, tmp_path):
        """Test that toolset files require tools field."""
        # Create toolset file without tools
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "invalid.mci.json").write_text(json.dumps({
            "schemaVersion": "1.0"
        }))
        
        # Create main schema
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "invalid"}
            ]
        }))
        
        # Should raise error
        with pytest.raises(SchemaParserError, match="missing required field 'tools'"):
            SchemaParser.parse_file(str(main_schema))

    def test_toolset_invalid_schema_version(self, tmp_path):
        """Test that toolset files validate schema version."""
        # Create toolset file with invalid schema version
        lib_dir = tmp_path / "mci"
        lib_dir.mkdir()
        
        (lib_dir / "invalid.mci.json").write_text(json.dumps({
            "schemaVersion": "99.0",
            "tools": [
                {"name": "tool1", "execution": {"type": "text", "text": "Tool 1"}}
            ]
        }))
        
        # Create main schema
        main_schema = tmp_path / "main.mci.json"
        main_schema.write_text(json.dumps({
            "schemaVersion": "1.0",
            "toolsets": [
                {"name": "invalid"}
            ]
        }))
        
        # Should raise error
        with pytest.raises(SchemaParserError, match="Unsupported schema version"):
            SchemaParser.parse_file(str(main_schema))
